#' Read ED2 data
#'
#' @param path path to the h5 files generated by ED2
#' @param sites site(s) or prefix(es)
#' @param type Q, T, D, etc.
#' @param variables (optional) variables to read in, as defined by the *names* of edvars below (eg. NPP), if "all" then all of edvars will be read
#' @param verbose (optional) echo's some progress on screen
#'
#' @return list of the form ed$site$var
#' @export
readOut.ED2 <- function(path,sites,type,yearlim="all",variables="all",verbose=FALSE){

  suppressMessages(require(lubridate))
  suppressMessages(require(rhdf5))
  suppressMessages(require(abind))

  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  #
  #  P R E P A R A T I O N
  #
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  # List all output files
  files.edout <- list.files(path = path, pattern = paste0("-",type,"-"))
  if(length(files.edout)==0) stop("No files of type ",type," found in ",path)

  # Define variables to select
  if(type=="Q") {                                                 # UNITS             DIMENSIONS
    edvars <- list( NPP = "MMEAN_NPP_PY",                         # [kgC/m2/year]    [time]
                    NEE = "MMEAN_NEP_PY",                         # [kgC/m2/year]    [time]
                    GPP = "MMEAN_GPP_PY",                         # [kgC/m2/year]    [time]
                    LAI.cohort = "MMEAN_LAI_PY",                  # [m2leaf/m2]       [pft,dbh,time]
                    AGB.cohort = "AGB_PY",                        # [kgC/m2]          [pft,dbh,time]

                    soil.C.slow   = "MMEAN_SLOW_SOIL_C_PY",       # [kgC/m2]          [time]
                    soil.C.struct = "MMEAN_STRUCT_SOIL_C_PY",     # [kgC/m2]          [time]
                    soil.C.fast = "MMEAN_FAST_SOIL_C_PY",         # [kgC/m2]          [time]
                    soil.h2o.flux = "MMEAN_SMOIST_GG_PY",         # [kg/m2/s]
                    soil.h2o.content = "MMEAN_SOIL_WATER_PY",     # [m3/m3]

                    soil.h2o.transp = "MMEAN_TRANSLOSS_PY",       # [kg/m2/s]
                    leaf.h2o.transp = "MMEAN_TRANSP_PY",          # [kg/m2/s]

                    leaf.h2o.evap = "MMEAN_VAPOR_LC_PY",          # [kg/m2/s]
                    ground.h2o.evap = "MMEAN_VAPOR_GC_PY",       # [kg/m2/s]
                    wood.h2o.evap = "MMEAN_VAPOR_WC_PY",          # [kg/m2/s]

                    h2o.available = "MMEAN_AVAILABLE_WATER_PY",   # [kg/m2]
                    h2o.drainage = "MMEAN_DRAINAGE_PY",           # [kg/m2/s]
                    h2o.runoff = "MMEAN_RUNOFF_PY",               # [kg/m2/s]
                    h2o.residual = "MMEAN_WATER_RESIDUAL_PY",     # [kg/m2]
                    h2o.supply = "MMEAN_WATER_SUPPLY_PY",         # [kg/m2/s]
                    #h2o.deficit = "AVG_MONTHLY_WATERDEF",         # [kg/m2/30days] this one gives an error for some reason...

                    stress.N = "MMEAN_FSN_PY",                    #
                    stress.M = "MMEAN_FSW_PY",                    #
                    stress.net = "MMEAN_FS_OPEN_PY",              #
                    rain.rate="MMEAN_PCPG_PY",                    # [mm/s]
                    leaf.gs="MMEAN_LEAF_GSW_PY"                   # [kg/m2leaf/s]
    )
  }


  if(type=="T") {
    edvars <- list( NPP = "FMEAN_NPP_PY",                   # [kgC/m2/year]
                    NEE = "FMEAN_NEP_PY",                   # [kgC/m2/year]
                    GPP = "FMEAN_GPP_PY",                   # [kgC/m2/year]
                    LAI = "FMEAN_LAI_PY",                        # [m2leaf/m2]
                    LAI.cohort = "LAI_PY",                       # [m2leaf/m2]

                    soil.C.slow   = "SLOW_SOIL_C_PY",            # [kgC/m2]
                    soil.C.struct = "STRUCT_SOIL_C_PY",          # [kgC/m2]
                    soil.C.fast = "FAST_SOIL_C_PY",              # [kgC/m2]
                    soil.h2o.transp = "FMEAN_TRANSLOSS_PY",      # [kg/m2/s]
                    soil.h2o.content = "FMEAN_SOIL_WATER_PY",    # [m3/m3]

                    # Variables needed to calculate LE:
                    leaf.h2o.transp = "FMEAN_TRANSP_PY",         # [kg/m2/s]
                    leaf.h2o.evap = "FMEAN_VAPOR_LC_PY",         # [kg/m2/s]
                    wood.h2o.evap = "FMEAN_VAPOR_WC_PY",         # [kg/m2/s]
                    ground.h2o.evap = "FMEAN_VAPOR_GC_PY",       # [kg/m2/s]

                    h2o.available = "FMEAN_AVAILABLE_WATER_PY",   # [kg/m2]
                    h2o.drainage = "FMEAN_DRAINAGE_PY",           # [kg/m2/s]
                    h2o.runoff = "FMEAN_RUNOFF_PY",               # [kg/m2/s]
                    h2o.supply = "FMEAN_WATER_SUPPLY_PY",         # [kg/m2/s]

                    AGB.total = "TOTAL_AGB",                     # [kgC/m2]
                    stress.N = "FMEAN_FSN_PY",                   # Nitrogen stress factor
                    stress.M = "FMEAN_FSW_PY",                   # Moisture stress factor
                    stress.net = "FMEAN_FS_OPEN_PY",             # Net stress factor
                    rain.rate="FMEAN_PCPG_PY",                   # [mm/s]
                    leaf.gs="FMEAN_LEAF_GSW_PY"                  # [kg/m2leaf/s]
    )
  }

  if(type=="D") {
    edvars <- list(   NPP = "DMEAN_NPP_PY",          # [kgC/m2/year]
                      NEE = "DMEAN_NEP_PY",          # [kgC/m2/year]
                      GPP = "DMEAN_GPP_PY",          # [kgC/m2/year]
                      LAI.cohort = "LAI_PY",              # [m2leaf/m2]
                      soil.C.slow   = "SLOW_SOIL_C_PY",   # [kgC/m2]
                      soil.C.struct = "STRUCT_SOIL_C_PY", # [kgC/m2]
                      soil.C.fast = "FAST_SOIL_C_PY",     # [kgC/m2]
                      AGB.cohort = "AGB_PY",              # [kgC/m2]
                      stress.N = "DMEAN_FSN_PY",          # Nitrogen stress factor
                      stress.M = "DMEAN_FSW_PY",          # Moisture stress factor
                      stress.net = "DMEAN_FS_OPEN_PY",    # Net stress factor
                      rain.rate="DMEAN_PCPG_PY",          # [mm/s]
                      leaf.gs="DMEAN_LEAF_GSW_PY"         # [kg/m2leaf/s]
    )
  }

  if(variables[[1]]!="all"){
    edvars<-edvars[names(edvars) %in% variables]
    if(length(edvars)<1) stop("Variables ",variables," not found!")
  }

  vars <- names(edvars)
  vars.flux <- c("NPP","GPP","NEE")


  # Time management tools
  sec_per_day <- 24*60*60
  yrdays <- function(tim){ return(365 + leap_year(tim)) }

  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  #
  #  READ ALL RELEVANT DATA
  #
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  if(verbose) cat("readOut.ED2 :: Reading data.\n")

  # Initialize list
  ed <- list()
  for(s in sites) ed[[s]] <- list()

  # Read
  for(s in sites){

    # Length of the prefix
    ind <- nchar(s)

    files.site <- files.edout[startsWith(files.edout,s)]
    if(length(files.site)<1) stop("No data found for site ",s)

    # Check if the year of the file is in the requested interval. Remove if not.
    files.site.keep <- logical()
    for(f in 1:length(files.site)){
      fileyear <- substr(files.site[[f]],ind+4,ind+7)
      files.site.keep[f] <- (yearlim[1]=="all" | (fileyear>=min(yearlim) & fileyear<=max(yearlim)))
    }
    files.site <- files.site[files.site.keep]


    for(f in 1:length(files.site)){

      # Save date info from filename
      ed[[s]]$year[f]  <- substr(files.site[f],ind+4,ind+7)
      ed[[s]]$month[f] <- substr(files.site[f],ind+9,ind+10)
      ed[[s]]$day[f]   <- substr(files.site[f],ind+12,ind+13)

      if(verbose) cat("readOut.ED2 :: -- Reading year-month-day ",ed[[s]]$year[f],"-",ed[[s]]$month[f],"-",ed[[s]]$day[f],"\n")

      # Read all vars of interest
      for(v in vars){
        ed[[s]][[v]][[f]] <- h5read(paste0(path,files.site[f]),name=edvars[[v]]);
      }
      H5close()
    }

  }

  if(verbose) cat("readOut.ED2 :: Done!\n")
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  #
  #  CONVERT DATES, VARS
  #
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  if(verbose) cat("readOut.ED2 :: Rearranging dates and vars a bit. ")

  # POSIX and variable arrangement fix
  for(s in sites) {


    ##
    ## Q OUT
    ##
    if(type=="Q"){
      ed[[s]]$posix <- with_tz(as.POSIXct(with_tz(ymd(paste0(ed[[s]]$year,ed[[s]]$month,"01")))),tzone="UTC")
      ed[[s]]$year  <- NULL
      ed[[s]]$month <- NULL
      ed[[s]]$day   <- NULL
      hour(ed$DAH$posix)<-0
      minute(ed$DAH$posix)<-0
      second(ed$DAH$posix)<-0
    }


    ##
    ## DAILY OUT
    ##
    if(type=="D"){
      ed[[s]]$posix <- with_tz(as.POSIXct(with_tz(ymd(paste0(ed[[s]]$year,ed[[s]]$month,ed[[s]]$day)))),tzone="UTC")
      ed[[s]]$year  <- NULL
      ed[[s]]$month <- NULL
      ed[[s]]$day   <- NULL
      hour(ed$DAH$posix)<-0
      minute(ed$DAH$posix)<-0
      second(ed$DAH$posix)<-0
    }

    ##
    ## TOWER OUT <<<<<<<<<<<<<<,, something wrong here probably..
    ##
    if(type=="T"){

      yrs <- length(ed[[s]]$year)

      # Generate sequence of POSIX each half hour
      yr.fr <- min(as.numeric(ed[[s]]$year))
      yr.to <- max(as.numeric(ed[[s]]$year))
      pos.fr <- as.POSIXct(ymd(paste0(yr.fr,"0101"),tz="UTC"))
      pos.to <- as.POSIXct(ymd(paste0(yr.to+1,"0101"),tz="UTC"))-minutes(30)
      ed[[s]]$posix <- seq.POSIXt(from=pos.fr,to=pos.to,by="30 min")
      ed[[s]]$year  <- NULL
      ed[[s]]$month <- NULL
      ed[[s]]$day   <- NULL

    }

    # Concatenate all vars
    for(v in vars){
      lastdim <- length(dim(ed[[s]][[v]][[1]])) # WATCH OUT: here we assume that the "last" dimension is the time dimension (ipoly), which is the case for T files
      ed[[s]][[v]] <- drop(do.call(abind,list(ed[[s]][[v]],along=lastdim)))
    }
  }

  if(verbose) cat("Done!\n")

  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  #
  #  DERIVING SOME VARIABLES
  #
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  # Calculate total soil carbon
  if(("soil.C.slow" %in% vars)&("soil.C.struct" %in% vars)&("soil.C.fast" %in% vars)) {
      for(s in sites)  ed[[s]]$soil.C.tot <- ed[[s]]$soil.C.slow + ed[[s]]$soil.C.struct + ed[[s]]$soil.C.fast
    }

  # Calculate PFT totals of LAI and AGB
  if("LAI.cohort" %in% vars) {for(s in sites)  ed[[s]]$LAI.pft <- apply(ed[[s]]$LAI.cohort,c(1,3),sum)}
  if("AGB.cohort" %in% vars) {for(s in sites)  ed[[s]]$AGB.pft <- apply(ed[[s]]$AGB.cohort,c(1,3),sum)}

  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  #
  #  CORRECT UNITS
  #
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  for(s in sites){
    for(v in vars.flux){
      if(v %in% vars){
        ed[[s]][[v]] <- ed[[s]][[v]]/(yrdays(ed[[s]]$posix)*sec_per_day)   # [kgC/m2/sec]
        attr(ed[[s]][[v]],"Units")<-"kgC m-2 s-1"
      }
    }
  }

  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  #
  #  SOME FINISHING TOUCHES
  #
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  for(s in sites){
    for(v in names(ed[[s]])){
      attr(ed[[s]][[v]],"dimnames")<-NULL
    }
  }


  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  #
  #  END
  #
  # - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -


  return(ed)

}


